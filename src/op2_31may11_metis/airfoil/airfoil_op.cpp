// 
// auto-generated by op2.m on 30-May-2011 22:03:11 
//

/*
  Open source copyright declaration based on BSD open source template:
  http://www.opensource.org/licenses/bsd-license.php

* Copyright (c) 2009-2011, Mike Giles
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * The name of Mike Giles may not be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//
//     Nonlinear airfoil lift calculation
//
//     Written by Mike Giles, 2010-2011, based on FORTRAN code
//     by Devendra Ghate and Mike Giles, 2005
//

//
// standard headers
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdbool.h> // Added by Nao for C99 boolean


// global constants

float gam, gm1, cfl, eps, mach, alpha, qinf[4];

//
// OP header file
//

#include "op_lib.h"


//
// partitioning header files Added By Nao
//

#include "op_part.h"
#include "op_part_metis.h"
#include "op_part_rcb.h"


//
// Profiling Added By Nao
//

#include "simple_timer.h"


int OP_part_size_res=0;

//
// Result Data Logging Added By Nao
//

#include <time.h>
#include <unistd.h>

//
// op_par_loop declarations
//

void op_par_loop_save_soln(char const *, op_set,
  op_arg,
  op_arg );

void op_par_loop_adt_calc(char const *, op_set,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg );

void op_par_loop_res_calc(char const *, op_set,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg );

void op_par_loop_bres_calc(char const *, op_set,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg );

void op_par_loop_update(char const *, op_set,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg );

// kernel routines for parallel loops
//

#include "save_soln.h"
#include "adt_calc.h"
#include "res_calc.h"
#include "bres_calc.h"
#include "update.h"

// main program

int main(int argc, char **argv){

  int    *becell, *ecell,  *bound, *bedge, *edge, *cell;
  float  *x, *q, *qold, *adt, *res;

  int    nnode,ncell,nedge,nbedge,niter;
  float  rms;

 	// reading arguments
	printf("reading arguments.. \n");
	int smartpart_size=-1;
	int smartpart_type=-1;
	bool isShuffle=false;
	bool isSmartPart=false;
	for (int n=1; n<argc; n++) {
		if (strncmp(argv[n],"SHUFFLE",7)==0) {
			isShuffle = true;
			printf("shuffle input data\n");
		}

		if (strncmp(argv[n],"METIS_D_PART_SIZE_RES=",22)==0) {
			isSmartPart=true;
			smartpart_size = atoi(argv[n]+22);
			smartpart_type = METIS_PART_D_MESH;
			printf("partdmesh smartpart_size=%d\n", smartpart_size);
		}

		if (strncmp(argv[n],"METIS_N_PART_SIZE_RES=",22)==0) {
			isSmartPart=true;
			smartpart_size = atoi(argv[n]+22);
			smartpart_type = METIS_PART_N_MESH;
			printf("partnmesh smartpart_size=%d\n", smartpart_size);
		}

		if (strncmp(argv[n],"RCB_PART_LEVEL_RES=",19)==0) {
			isSmartPart=true;
			smartpart_size = atoi(argv[n]+19);
			smartpart_type = RCB_PART;
			printf("rcb partition level=%d\n", smartpart_size);
		}

		// number of threads per block
		if (strncmp(argv[n],"OP_PART_SIZE_RES=",17)==0) {
			OP_part_size_res = atoi(argv[n]+17);
			printf("OP_part_size_res=%d\n", OP_part_size_res);
		}
	}

	printf("reading in grid \n");

 	// generate input file name
	char *mesh_data_path;
	mesh_data_path = getenv("OP2_MESH_PATH");

	char infile[256];
	if(mesh_data_path == NULL)
		strcpy(infile, "../../airfoil-input");
	else
		strcpy(infile, mesh_data_path);

	if(isShuffle)
		strcat(infile, "/new_grid_rand-600-400.dat");
	else
		strcat(infile, "/new_grid-600-400.dat");
//		strcat(infile, "/new_grid.dat");

	FILE *fp;
	if ( (fp = fopen(infile,"r")) == NULL) {
		printf("can't open file %s\n", infile); exit(-1);
	}

	if (fscanf(fp,"%d %d %d %d \n",&nnode, &ncell, &nedge, &nbedge) != 4) {
		printf("error reading from new_grid.dat\n"); exit(-1);
	}

  // <op_map memory allocation>
  // cell   : mapping between cell and node (1 cell shares 4 nodes)
  // edge   : mapping between edge and node (1 edge shares 2 nodes)
  // ecell  : mapping between edge and cell (1 edge shares 2 cells)
  // bedge  : mapping between boundary edge and node
  // becell : mapping between boundary edge and cell	
  cell   = (int *) malloc(4*ncell*sizeof(int));
  edge   = (int *) malloc(2*nedge*sizeof(int));
  ecell  = (int *) malloc(2*nedge*sizeof(int));
  bedge  = (int *) malloc(2*nbedge*sizeof(int));
  becell = (int *) malloc(  nbedge*sizeof(int));

  // <op_data memory allocation>
  bound  = (int *)   malloc(  nbedge*sizeof(int));
  x      = (float *) malloc(2*nnode*sizeof(float));
  q      = (float *) malloc(4*ncell*sizeof(float));
  qold   = (float *) malloc(4*ncell*sizeof(float));
  res    = (float *) malloc(4*ncell*sizeof(float));
  adt    = (float *) malloc(  ncell*sizeof(float));

  // Read x coordinate
  for (int n=0; n<nnode; n++) {
    if (fscanf(fp,"%f %f \n",&x[2*n], &x[2*n+1]) != 2) {
      printf("error reading from new_grid.dat\n"); exit(-1);
    }
  }

  // Read cell data (cell-node) 
  for (int n=0; n<ncell; n++) {
    if (fscanf(fp,"%d %d %d %d \n",&cell[4*n  ], &cell[4*n+1],
                                   &cell[4*n+2], &cell[4*n+3]) != 4) {
      printf("error reading from new_grid.dat\n"); exit(-1);
    }
  }

  // Read edge data (edge-node) and ecell data (edge-cell) 
  for (int n=0; n<nedge; n++) {
    if (fscanf(fp,"%d %d %d %d \n",&edge[2*n], &edge[2*n+1],
                                   &ecell[2*n],&ecell[2*n+1]) != 4) {
      printf("error reading from new_grid.dat\n"); exit(-1);
    }
  }

  // Read boundary edge data (edge-node), boundary edge cell data (edge-cell) 
  for (int n=0; n<nbedge; n++) {
    if (fscanf(fp,"%d %d %d %d \n",&bedge[2*n],&bedge[2*n+1],
                                   &becell[n], &bound[n]) != 4) {
      printf("error reading from new_grid.dat\n"); exit(-1);
    }
  }

  fclose(fp);

	// Calculate number of partitioning
	int numofpart;
	if(isSmartPart){
		switch (smartpart_type){
			// Metis Partitioning
			case METIS_PART_D_MESH:
			case METIS_PART_N_MESH:
				numofpart=nedge/smartpart_size;
				break;
			case RCB_PART:
				numofpart=1<<smartpart_size;
				break;

			default:
				printf("Error:specified partition argument is not valid.\n");
				exit(-1);
		}
	}else
		// sequential partitioning does not use this parameter.
		numofpart=0;


  // set constants and initialise flow field and residual

  printf("initialising flow field \n");

  gam = 1.4f;
  gm1 = gam - 1.0f;
  cfl = 0.9f;
  eps = 0.05f;

  float mach  = 0.4f;
  float alpha = 3.0f*atan(1.0f)/45.0f;  
  float p     = 1.0f;
  float r     = 1.0f;
  float u     = sqrt(gam*p/r)*mach;
  float e     = p/(r*gm1) + 0.5f*u*u;

  qinf[0] = r;
  qinf[1] = r*u;
  qinf[2] = 0.0f;
  qinf[3] = r*e;

  for (int n=0; n<ncell; n++) {
    for (int m=0; m<4; m++) {
        q[4*n+m] = qinf[m];
      res[4*n+m] = 0.0f;
    }
  }

	point *partnode = new point[nnode];
	point *partedge = new point[nedge];
	point *partbedge = new point[nbedge];
	point *partcell = new point[ncell];
	int *node_part_info = (int *) calloc(numofpart, sizeof(int));
	int *edge_part_info = (int *) calloc(numofpart, sizeof(int));
	int *bedge_part_info = (int *) calloc(numofpart, sizeof(int));
	int *cell_part_info = (int *) calloc(numofpart, sizeof(int));

	// Partitioning Profiling Added By Nao
	SimpleTimer part_timer("partition");

	if(!isSmartPart){
		// for calculating edge_cut
		int bsize;
		(OP_part_size_res==0)?bsize=512:bsize=OP_part_size_res;

		// Set edge partition data
		for(int idx_edge=0; idx_edge<nedge; idx_edge++)
			partedge[idx_edge].part= (int)(idx_edge/bsize);

		// Apply edge partition data to node
		int nodeID1, nodeID2;
		for(int idx_edge=0; idx_edge<nedge; idx_edge++){
			nodeID1 = edge[2*idx_edge  ];
			nodeID2 = edge[2*idx_edge+1];
			partnode[nodeID1].part = partedge[idx_edge].part;
			partnode[nodeID2].part = partedge[idx_edge].part;
		}
	}
	else{

       part_timer.start();

		switch (smartpart_type){
			// Metis Partitioning
			case METIS_PART_D_MESH:
			case METIS_PART_N_MESH:
				part_metis(smartpart_type, numofpart, CELL_TYPE_QUADRILATERAL, 
					 		 nnode, nedge, nbedge, ncell,
					 		 partnode, partedge, partbedge, partcell,
					 		 cell, ecell, becell);
				break;
			case RCB_PART:
				part_rcb(smartpart_size, 2,
						nnode, nedge, nbedge, ncell,
						partnode, partedge, partbedge, partcell,
						cell, ecell, becell, edge, x);
				break;
			default:
				printf("Error:specified partition argument is not valid.\n");
				exit(-1);
		} // switch (smartpart_type)

       part_timer.stop_and_add_to_total();
       printf("partitioning=%lf\n", part_timer.total_time());
       
		// Re-Alignment Memory Order
		part_MemAlignment(numofpart,
							 nnode, nedge, nbedge, ncell,
							 partnode, partedge, partbedge, partcell,
							 node_part_info, edge_part_info, bedge_part_info, cell_part_info,
							 cell, edge, ecell, bedge, becell,
							 bound, x, q, qold, res, adt);
	}

	// Calculate Edge Cut
	int edge_cut=0;
	edge_cut = part_CalcEdgecut(nedge, nnode, edge, partnode);
	printf("edge_cut=%d\n", edge_cut);

	// OP initialisation
	op_init(argc,argv,2);

	// declare sets, pointers, datasets and global constants
	op_set nodes;
	op_set edges;
	op_set bedges;
	op_set cells;
	if(isSmartPart){
		nodes  = op_decl_set(nnode, "nodes");
		edges  = op_decl_set_smart(nedge, numofpart, edge_part_info, "edges");
		bedges = op_decl_set(nbedge, "bedges");
		cells  = op_decl_set(ncell,  "cells");

//		nodes  = op_decl_set_smart(nnode, numofpart, node_part_info, "nodes");
//		edges  = op_decl_set_smart(nedge, numofpart, edge_part_info, "edges");
//		bedges = op_decl_set_smart(nbedge, numofpart, bedge_part_info,  "bedges");
//		cells  = op_decl_set(ncell,  "cells");
	}else{
		nodes  = op_decl_set(nnode,  "nodes");
		edges  = op_decl_set(nedge,  "edges");
		bedges = op_decl_set(nbedge, "bedges");
		cells  = op_decl_set(ncell,  "cells");
	}

	op_map pedge   = op_decl_map(edges, nodes,2,edge,  "pedge");
	op_map pecell  = op_decl_map(edges, cells,2,ecell, "pecell");
	op_map pbedge  = op_decl_map(bedges,nodes,2,bedge, "pbedge");
	op_map pbecell = op_decl_map(bedges,cells,1,becell,"pbecell");
	op_map pcell   = op_decl_map(cells, nodes,4,cell,  "pcell");

	op_dat p_bound = op_decl_dat(bedges,1,"int"  ,bound,"p_bound");
	op_dat p_x     = op_decl_dat(nodes ,2,"float",x    ,"p_x");
	op_dat p_q     = op_decl_dat(cells ,4,"float",q    ,"p_q");
	op_dat p_qold  = op_decl_dat(cells ,4,"float",qold ,"p_qold");
	op_dat p_adt   = op_decl_dat(cells ,1,"float",adt  ,"p_adt");
	op_dat p_res   = op_decl_dat(cells ,4,"float",res  ,"p_res");

	op_decl_const2("gam",1,"float",&gam  );
	op_decl_const2("gm1",1,"float",&gm1  );
	op_decl_const2("cfl",1,"float",&cfl  );
	op_decl_const2("eps",1,"float",&eps  );
	op_decl_const2("mach",1,"float",&mach );
	op_decl_const2("alpha",1,"float",&alpha);
	op_decl_const2("qinf",4,"float",qinf  );

	op_diagnostic_output();

  // main time-marching loop
  niter = 1000;

  for(int iter=1; iter<=niter; iter++) {

	// save old flow solution
    op_par_loop_save_soln("save_soln", cells,
                op_arg_dat(p_q,   -1,OP_ID, 4,"float",OP_READ ),
                op_arg_dat(p_qold,-1,OP_ID, 4,"float",OP_WRITE));

	// predictor/corrector update loop
    for(int k=0; k<2; k++) {

	  // calculate area/timstep
      op_par_loop_adt_calc("adt_calc",cells,
                  op_arg_dat(p_x,   0,pcell, 2,"float",OP_READ ),
                  op_arg_dat(p_x,   1,pcell, 2,"float",OP_READ ),
                  op_arg_dat(p_x,   2,pcell, 2,"float",OP_READ ),
                  op_arg_dat(p_x,   3,pcell, 2,"float",OP_READ ),
                  op_arg_dat(p_q,  -1,OP_ID, 4,"float",OP_READ ),
                  op_arg_dat(p_adt,-1,OP_ID, 1,"float",OP_WRITE));

	  // calculate flux residual
      op_par_loop_res_calc("res_calc",edges,
                  op_arg_dat(p_x,    0,pedge, 2,"float",OP_READ),
                  op_arg_dat(p_x,    1,pedge, 2,"float",OP_READ),
                  op_arg_dat(p_q,    0,pecell,4,"float",OP_READ),
                  op_arg_dat(p_q,    1,pecell,4,"float",OP_READ),
                  op_arg_dat(p_adt,  0,pecell,1,"float",OP_READ),
                  op_arg_dat(p_adt,  1,pecell,1,"float",OP_READ),
                  op_arg_dat(p_res,  0,pecell,4,"float",OP_INC ),
                  op_arg_dat(p_res,  1,pecell,4,"float",OP_INC ));

      op_par_loop_bres_calc("bres_calc",bedges,
                  op_arg_dat(p_x,     0,pbedge, 2,"float",OP_READ),
                  op_arg_dat(p_x,     1,pbedge, 2,"float",OP_READ),
                  op_arg_dat(p_q,     0,pbecell,4,"float",OP_READ),
                  op_arg_dat(p_adt,   0,pbecell,1,"float",OP_READ),
                  op_arg_dat(p_res,   0,pbecell,4,"float",OP_INC ),
                  op_arg_dat(p_bound,-1,OP_ID  ,1,"int",  OP_READ));

	  // update flow field
      rms = 0.0;

      op_par_loop_update("update",cells,
                  op_arg_dat(p_qold,-1,OP_ID, 4,"float",OP_READ ),
                  op_arg_dat(p_q,   -1,OP_ID, 4,"float",OP_WRITE),
                  op_arg_dat(p_res, -1,OP_ID, 4,"float",OP_RW   ),
                  op_arg_dat(p_adt, -1,OP_ID, 1,"float",OP_READ ),
                  op_arg_gbl(&rms,1,"float",OP_INC));
    }

	// print iteration history
    rms = sqrt(rms/(float) ncell);

    if (iter%100 == 0)
      printf(" %d  %10.5e \n",iter,rms);
  }

	op_timing_output();

	// free partition memory
	delete[] partnode;
	delete[] partcell;
	delete[] partedge;
	delete[] partbedge;


	// Output Result
	op_fetch_data(p_q);

	char *rslt_path;
	rslt_path = getenv("OP2_RSLT_PATH");

	char resfile[256];
	if(rslt_path == NULL)
		strcpy(resfile, "../../airfoil-output");
	else
		strcpy(resfile, rslt_path);

	strcat(resfile, "/result.dat");

	FILE *fp_rslt;
	if ( (fp_rslt = fopen(resfile,"w")) == NULL) {
		printf("can't generate file %s\n", resfile); exit(-1);
	}

	float *rslt_data=(float*)p_q->data;
	for(int i=0; i< (p_q->dim)*(p_q->set->size); i++){
		fprintf(fp_rslt, "%9.9f\n", rslt_data[i]);
	} 

	fclose(fp_rslt);

	// Read & Compare Reference Result
	char *ref_path;
	ref_path = getenv("OP2_RSLT_PATH");

	char reffile[256];
	if(ref_path == NULL)
		strcpy(reffile, "../../airfoil-output");
	else
		strcpy(reffile, ref_path);

	if(isShuffle)
		strcat(reffile, "/mike_result_rand600-400.dat");
//		strcat(reffile, "/mike_result_rand.dat");
	else
//		strcat(reffile, "/mike_result60-40.dat");
//		strcat(reffile, "/mike_result.dat");
		strcat(reffile, "/mike_result600-400.dat");


	FILE *fp_ref;
	if ( (fp_ref = fopen(reffile,"r")) == NULL) {
		printf("can't open file %s\n", reffile); exit(-1);
	}

	if ( (fp_rslt = fopen(resfile,"r")) == NULL) {
		printf("can't open file %s\n", resfile); exit(-1);
	}

	double ref_data, res_data;
	double difftmp, diffmin=9999999.9999, diffmax=-9999999.9999;
	int min_index=-1, max_index=-1;
	for(int i=0; i< (p_q->dim)*(p_q->set->size); i++){
		fscanf(fp_ref, "%lf", &ref_data);
		fscanf(fp_rslt, "%lf", &res_data);
		difftmp=res_data-ref_data;

		if(diffmin>difftmp) {diffmin=difftmp; min_index=i;} 
		if(diffmax<difftmp) {diffmax=difftmp; max_index=i;}
	} 
	printf("\n");
	printf("Min Diff:%9.9lf @ index [%d] \n", diffmin, min_index);
	printf("Max Diff:%9.9lf @ index [%d] \n", diffmax, max_index);
	fclose(fp_ref);
	fclose(fp_rslt);


	// Output performance data
	char *per_path;
	per_path = getenv("OP2_RSLT_PATH");

	char perfile[256];
	if(per_path == NULL)
		strcpy(perfile, "../../airfoil-output");
	else
		strcpy(perfile, per_path);

	strcat(perfile, "/perresult.dat");

	bool isFileExist=true;
	if(access(perfile, R_OK)==-1) isFileExist=false;


	FILE *fp_per;
	if ( (fp_per = fopen(perfile,"a")) == NULL) {
		printf("can't generate/find file %s\n", perfile); exit(-1);
	}

	// Write header
	if(isFileExist==false) {
		fprintf(fp_per, "<is shuffle>, <partition type>, <smart part>, <edge cut>, <num of blocks>, <block size>, <num of colors>, <num of threadcolors>, <max block size>, <shared mem>, <time>, <kernel>, <min error>, <max error>, <time of exec>\n");
	}

	time_t timer;
	time(&timer);
	tm *ct = localtime(&timer);

	int numofker=op_kernel_getnum();
	op_kernel* kerPtr = op_kernel_getptr();

	op_plan* myplan=op_plan_getByName("res_calc");
	if(myplan == NULL) {printf("Can not find specified plan"); exit(-1);}

	char parttype[256];
	if(isSmartPart) strcpy(parttype,"smart_partition");
	else strcpy(parttype,"sequential_partition");

	for (int n=0; n<numofker; n++) {
		if (kerPtr[n].count>0) {
			if (strcmp(kerPtr[n].name,"res_calc")==0) {
				fprintf(fp_per, "%s, %s, %d, %d, %6d, %6d, %6d, %6d, %d, %.2f KB, %8.4f, %s, %5.10lf, %5.10lf, %s",
						 (isShuffle)?"shuffling":"non-shuffling",
						 parttype,
						 smartpart_type,
						 edge_cut,
						 myplan->nblocks,
						 OP_block_size,
						 myplan->ncolors,
						 myplan->max_nthrcol,
						 myplan->maxbsize,
						 myplan->nshared/1024.0f,
						 OP_kernels[n].time,
						 OP_kernels[n].name,
						 diffmin,
						 diffmax,
						 asctime(ct));
			}
		}
	}

	fclose(fp_per);

}

